<h1 id="extraction-before-getline"><a aria-hidden="true" class="anchor-heading icon-link" href="#extraction-before-getline"></a>Extraction before Getline</h1>
<h3 id="extraction-before-getline-1"><a aria-hidden="true" class="anchor-heading icon-link" href="#extraction-before-getline-1"></a>Extraction Before Getline</h3>
<blockquote>
<p>The <code>getline()</code> function and the extraction operator <code>>></code> handle a trailing newline differently, which can lead to a problem.</p>
<ul>
<li>The <code>getline()</code> function reads a line of text from a buffer, <strong>discarding the ending newline character</strong>.</li>
<li>The extraction operator <code>>></code> skips <u>whitespace</u>, then reads the next item such as an integer or string which is said to end at the next <u>whitespace</u>, leaving that ending whitespace character in the buffer (an exception being for reading a single character).</li>
</ul>
</blockquote>
<blockquote>
<p>The problem is that code like <code>cin >> myInt;</code> and <code>getline(cin, nextLine);</code> may not behave as expected if the integer is ended with a newline. The <code>getline()</code> function will read that single remaining newline character, returning an empty string, rather than proceeding to the next line.
.
A simple solution is to not mix the two approaches to reading an input buffer, either only using extraction, or only using <code>getline()</code>.
.
If one must mix the two approaches, then after an extraction operation, the trailing newline should be discarded from the buffer before calling the <code>getline()</code>, by inserting some statement in between. One possible solution inserts <code>cin.ignore()</code>, which discards the next character in the input buffer. Another possible approach inserts another <code>getline()</code> call, ignoring its blank string.</p>
</blockquote>